<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# MiniMeet Development: Step-by-Step Implementation Guide

## **Initial Setup \& Environment Preparation**

### **Prerequisites Installation**

```bash
# Install required tools
node --version  # Ensure Node.js 18+
npm install -g @nestjs/cli
docker --version  # For database containers

# Create project workspace
mkdir minimeet-project
cd minimeet-project
```


### **What to Set Up First: Database Foundation**

Start with databases because they're the foundationâ€”you can test data operations before adding complex real-time features.

**Docker Compose Setup** (Start here - Day 1):

```yaml
# docker-compose.yml
version: '3.8'
services:
  mysql:
    image: mysql:8.0
    container_name: minimeet-mysql
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: minimeet
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql

  mongodb:
    image: mongo:6.0
    container_name: minimeet-mongo
    ports:
      - "27017:27017"
    volumes:
      - mongo_data:/data/db

  redis:
    image: redis:7-alpine
    container_name: minimeet-redis
    ports:
      - "6379:6379"

volumes:
  mysql_data:
  mongo_data:
```

**Start databases**:

```bash
docker-compose up -d
# Verify they're running
docker ps
```


## **Phase 1: Backend Foundation (Days 1-5)**

### **Milestone 1.1: NestJS Project Setup (Day 1)**

**Create backend**:

```bash
npx @nestjs/cli new minimeet-server
cd minimeet-server
npm install @nestjs/typeorm typeorm mysql2
npm install @nestjs/config
```

- [x] **Test milestone**: Server starts successfully

```bash
npm run start:dev
# Visit http://localhost:3000 - should see "Hello World!"
```

```bash
# Inside minimeet-server directory
npm run start:dev    # Starts the server
npx nest generate module users  # Generate components
```

### **Milestone 1.2: Database Connections (Day 2)**

**Configure TypeORM**:

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [
    ConfigModule.forRoot(),
    TypeOrmModule.forRoot({
      type: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'password',
      database: 'minimeet',
      autoLoadEntities: true,
      synchronize: true, // Only for development
    }),
  ],
})
export class AppModule {}
```

**Test milestone**: Database connection works

```bash
npm run start:dev
# Check logs - should see "Database connection established"
```


### **Milestone 1.3: First Entity \& CRUD (Days 3-4)**

**Create User entity**:

```bash
nest generate module users
nest generate service users
nest generate controller users
```

```typescript
// src/users/entities/user.entity.ts
import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  email: string;

  @Column()
  username: string;

  @Column({ default: true })
  isActive: boolean;

  @CreateDateColumn()
  createdAt: Date;
}
```

**Test milestone**: Create and retrieve users via REST API

```bash
# POST http://localhost:3000/users
curl -X POST http://localhost:3000/users \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","username":"testuser"}'

# GET http://localhost:3000/users
curl http://localhost:3000/users
```


### **Milestone 1.4: Room Entity \& Relationships (Day 5)**

```typescript
// src/rooms/entities/room.entity.ts
@Entity()
export class Room {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  name: string;

  @Column({ default: 4 })
  maxParticipants: number;

  @ManyToMany(() => User, user => user.rooms)
  @JoinTable()
  participants: User[];

  @CreateDateColumn()
  createdAt: Date;
}
```

**Test milestone**: Create rooms and add participants

```bash
# Create room
curl -X POST http://localhost:3000/rooms \
  -H "Content-Type: application/json" \
  -d '{"name":"Test Room"}'

# Add user to room
curl -X POST http://localhost:3000/rooms/ROOM_ID/participants \
  -H "Content-Type: application/json" \
  -d '{"userId":"USER_ID"}'
```


## **Phase 2: Real-Time Foundation (Days 6-10)**

### **Milestone 2.1: Socket.io Integration (Days 6-7)**

**Install WebSocket dependencies**:

```bash
npm install @nestjs/websockets @nestjs/platform-socket.io socket.io
```

**Create WebSocket Gateway**:

```bash
nest generate gateway websocket
```

```typescript
// src/websocket/websocket.gateway.ts
@WebSocketGateway({
  cors: { origin: 'http://localhost:3000' },
})
export class WebsocketGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer() server: Server;

  handleConnection(client: Socket) {
    console.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    console.log(`Client disconnected: ${client.id}`);
  }

  @SubscribeMessage('ping')
  handlePing(@ConnectedSocket() client: Socket): string {
    return 'pong';
  }
}
```

**Test milestone**: WebSocket connection works

```html
<!-- Create simple test page: test-websocket.html -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
<script>
  const socket = io('http://localhost:3000');
  socket.emit('ping');
  socket.on('pong', () => console.log('WebSocket working!'));
</script>
```


### **Milestone 2.2: Room Management via WebSocket (Days 8-9)**

```typescript
@SubscribeMessage('join_room')
async handleJoinRoom(
  @ConnectedSocket() client: Socket,
  @MessageBody() data: { roomId: string, userId: string }
) {
  await client.join(data.roomId);
  client.to(data.roomId).emit('user_joined', {
    userId: data.userId,
    socketId: client.id
  });
  return { status: 'joined', roomId: data.roomId };
}

@SubscribeMessage('send_message')
handleMessage(
  @ConnectedSocket() client: Socket,
  @MessageBody() data: { roomId: string, message: string, userId: string }
) {
  client.to(data.roomId).emit('new_message', {
    message: data.message,
    userId: data.userId,
    timestamp: new Date(),
  });
}
```

**Test milestone**: Multiple users can join rooms and chat

```javascript
// Test with 2 browser tabs
const socket1 = io('http://localhost:3000');
const socket2 = io('http://localhost:3000');

// Tab 1
socket1.emit('join_room', { roomId: 'test-room', userId: 'user1' });
socket1.on('new_message', (data) => console.log('Received:', data));

// Tab 2
socket2.emit('join_room', { roomId: 'test-room', userId: 'user2' });
socket2.emit('send_message', { roomId: 'test-room', message: 'Hello!', userId: 'user2' });
```


### **Milestone 2.3: Basic Frontend (Day 10)**

**Create React app**:

```bash
cd ..  # Back to project root
npm create vite@latest minimeet-client -- --template react-ts
cd minimeet-client
npm install socket.io-client
npm install @mui/material @emotion/react @emotion/styled
```

**Simple chat interface**:

```typescript
// src/components/ChatRoom.tsx
import { useEffect, useState } from 'react';
import { io, Socket } from 'socket.io-client';

export default function ChatRoom() {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [messages, setMessages] = useState<any[]>([]);
  const [message, setMessage] = useState('');

  useEffect(() => {
    const newSocket = io('http://localhost:3001');
    setSocket(newSocket);

    newSocket.emit('join_room', { roomId: 'test-room', userId: 'user1' });

    newSocket.on('new_message', (data) => {
      setMessages(prev => [...prev, data]);
    });

    return () => newSocket.close();
  }, []);

  const sendMessage = () => {
    if (socket && message.trim()) {
      socket.emit('send_message', {
        roomId: 'test-room',
        message,
        userId: 'user1'
      });
      setMessage('');
    }
  };

  return (
    <div>
      <div style={{ height: '300px', overflow: 'auto', border: '1px solid #ccc' }}>
        {messages.map((msg, index) => (
          <div key={index}>
            <strong>{msg.userId}:</strong> {msg.message}
          </div>
        ))}
      </div>
      <input
        value={message}
        onChange={(e) => setMessage(e.target.value)}
        onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
      />
      <button onClick={sendMessage}>Send</button>
    </div>
  );
}
```

**Test milestone**: Chat works in browser

```bash
npm run dev  # Frontend runs on http://localhost:5173
# Open multiple browser tabs - messages should appear in real-time
```


## **Phase 3: WebRTC Video (Days 11-15)**

### **Milestone 3.1: WebRTC Signaling (Days 11-12)**

**Add WebRTC signaling events**:

```typescript
// In websocket.gateway.ts
@SubscribeMessage('webrtc_offer')
handleOffer(
  @ConnectedSocket() client: Socket,
  @MessageBody() data: { roomId: string, offer: any, targetUserId: string }
) {
  client.to(data.roomId).emit('webrtc_offer', {
    offer: data.offer,
    fromUserId: client.id,
    targetUserId: data.targetUserId
  });
}

@SubscribeMessage('webrtc_answer')
handleAnswer(
  @ConnectedSocket() client: Socket,
  @MessageBody() data: { roomId: string, answer: any, targetUserId: string }
) {
  client.to(data.roomId).emit('webrtc_answer', {
    answer: data.answer,
    fromUserId: client.id
  });
}

@SubscribeMessage('ice_candidate')
handleIceCandidate(
  @ConnectedSocket() client: Socket,
  @MessageBody() data: { roomId: string, candidate: any, targetUserId: string }
) {
  client.to(data.roomId).emit('ice_candidate', {
    candidate: data.candidate,
    fromUserId: client.id
  });
}
```


### **Milestone 3.2: WebRTC Client Implementation (Days 13-14)**

```typescript
// src/hooks/useWebRTC.ts
import { useEffect, useRef, useState } from 'react';

export const useWebRTC = (socket: Socket | null, roomId: string) => {
  const [localStream, setLocalStream] = useState<MediaStream | null>(null);
  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);
  const peerConnection = useRef<RTCPeerConnection | null>(null);

  useEffect(() => {
    initializeWebRTC();
    return () => {
      peerConnection.current?.close();
      localStream?.getTracks().forEach(track => track.stop());
    };
  }, [socket]);

  const initializeWebRTC = async () => {
    try {
      // Get local media
      const stream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true
      });
      setLocalStream(stream);

      // Create peer connection
      peerConnection.current = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      // Add local tracks
      stream.getTracks().forEach(track => {
        peerConnection.current?.addTrack(track, stream);
      });

      // Handle remote stream
      peerConnection.current.ontrack = (event) => {
        setRemoteStream(event.streams[0]);
      };

      // Handle ICE candidates
      peerConnection.current.onicecandidate = (event) => {
        if (event.candidate && socket) {
          socket.emit('ice_candidate', {
            roomId,
            candidate: event.candidate,
            targetUserId: 'other-user'
          });
        }
      };

    } catch (error) {
      console.error('Failed to initialize WebRTC:', error);
    }
  };

  return { localStream, remoteStream, peerConnection: peerConnection.current };
};
```

**Test milestone**: Two browser tabs can see each other's video

```bash
# Open two browser tabs
# Both should show local video and request camera permission
# After signaling, remote video should appear
```


### **Milestone 3.3: Complete Video Chat (Day 15)**

```typescript
// src/components/VideoChat.tsx
export default function VideoChat() {
  const [socket, setSocket] = useState<Socket | null>(null);
  const { localStream, remoteStream } = useWebRTC(socket, 'video-room');
  const localVideoRef = useRef<HTMLVideoElement>(null);
  const remoteVideoRef = useRef<HTMLVideoElement>(null);

  useEffect(() => {
    if (localVideoRef.current && localStream) {
      localVideoRef.current.srcObject = localStream;
    }
  }, [localStream]);

  useEffect(() => {
    if (remoteVideoRef.current && remoteStream) {
      remoteVideoRef.current.srcObject = remoteStream;
    }
  }, [remoteStream]);

  return (
    <div>
      <div style={{ display: 'flex', gap: '20px' }}>
        <div>
          <h3>Local Video</h3>
          <video
            ref={localVideoRef}
            autoPlay
            muted
            style={{ width: '300px', height: '200px' }}
          />
        </div>
        <div>
          <h3>Remote Video</h3>
          <video
            ref={remoteVideoRef}
            autoPlay
            style={{ width: '300px', height: '200px' }}
          />
        </div>
      </div>
      <ChatRoom />
    </div>
  );
}
```

**Test milestone**: Full video chat with text messaging works between two browsers

## **Progress Validation Strategy**

### **Daily Check-ins**

- **End of each day**: One specific feature must be demonstrably working
- **Visual proof**: Screenshot or screen recording of working functionality
- **Code commit**: Push working code to Git with descriptive commit messages


### **Weekly Demos**

- **Week 1**: "I can create users and rooms via REST API"
- **Week 2**: "Multiple users can join rooms and chat in real-time"
- **Week 3**: "Two users can have video calls with chat"
- **Week 4**: "System handles multiple rooms with analytics"


### **Success Metrics**

Each milestone is complete when:

1. **Feature works** as intended
2. **No errors** in browser console or server logs
3. **Multiple users** can interact simultaneously
4. **Code is clean** and follows NestJS conventions

This incremental approach ensures you always have something working to show, making steady progress toward the complete video chat system that demonstrates all the required technologies from the job posting.
