<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# Video Chat POC Application Design

Let me help you design a **simplified but complete video chat application** that demonstrates all their key technologies. This POC will showcase your understanding of their architecture while being buildable as a portfolio project.

## **Application Overview: "MiniMeet"**

**Core Features**:

- User registration/authentication
- Create/join video chat rooms
- 1-on-1 and group video calls (up to 4 participants)
- Real-time text chat alongside video
- Chat history search
- Basic call analytics
- User presence indicators


## **Technology Mapping \& Alternatives**

### **Production Stack → POC Alternatives**

| Production | POC Alternative | Reason |
| :-- | :-- | :-- |
| AWS EKS | Docker Compose | Local development, easier setup |
| AWS DocumentDB | MongoDB (local) | Same API, free for development |
| AWS Aurora | MySQL (local) | Same database engine |
| Janus Gateway | Simple WebRTC SFU | Open source alternative |
| AWS ElasticSearch | ElasticSearch (Docker) | Same technology, containerized |
| Apache Kafka | Redis Streams | Simpler setup, similar functionality |

## **Detailed Architecture Design**

### **Backend Services Architecture**

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Frontend      │    │   API Gateway    │    │  Media Server   │
│   (React+TS)    │◄──►│   (NestJS)       │◄──►│   (Janus Alt)   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                                │
                    ┌───────────┼───────────┐
                    │           │           │
            ┌───────▼──┐ ┌──────▼──┐ ┌─────▼─────┐
            │ Socket.io│ │Database │ │  Cache/   │
            │ Service  │ │Services │ │ Analytics │
            └──────────┘ └─────────┘ └───────────┘
```


### **Service Breakdown**

#### **1. API Gateway Service (NestJS + TypeScript)**

```typescript
// Core modules structure
src/
├── auth/           # JWT authentication
├── users/          # User management
├── rooms/          # Video room management  
├── chat/           # Chat message handling
├── websocket/      # Socket.io gateway
├── analytics/      # Call metrics
└── common/         # Shared utilities
```


#### **2. Database Layer (TypeORM)**

```typescript
// Entity relationships
User ──┐
       ├─► Room (many-to-many)
       └─► ChatMessage (one-to-many)
       
Room ──┐
       ├─► ChatMessage (one-to-many)
       └─► CallSession (one-to-many)
```


#### **3. Real-time Communication (Socket.io + WebRTC)**

```typescript
// WebSocket event handlers
- 'join_room' → Room management
- 'leave_room' → Cleanup connections
- 'webrtc_offer' → Peer connection signaling
- 'webrtc_answer' → Response handling
- 'ice_candidate' → Network traversal
- 'chat_message' → Text messaging
```


## **Step-by-Step Development Approach**

### **Phase 1: Foundation (Week 1)**

**Day 1-2: Project Setup**

```bash
# Backend setup
nest new minimeet-server
cd minimeet-server
npm install @nestjs/websockets @nestjs/platform-socket.io
npm install @nestjs/typeorm typeorm mysql2 mongodb
npm install socket.io redis ioredis
npm install @nestjs/jwt @nestjs/passport passport-jwt

# Frontend setup  
npm create vite@latest minimeet-client -- --template react-ts
cd minimeet-client
npm install socket.io-client @types/socket.io-client
npm install @mui/material @emotion/react @emotion/styled
```

**Day 3-5: Core NestJS Structure**

```typescript
// app.module.ts - Main application module
@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'mysql',
      host: 'localhost',
      port: 3306,
      database: 'minimeet',
      autoLoadEntities: true,
      synchronize: true, // Only for development
    }),
    AuthModule,
    UsersModule,
    RoomsModule,
    ChatModule,
    WebsocketModule,
  ],
})
export class AppModule {}
```

**Day 6-7: Database Entities (TypeORM)**

```typescript
@Entity()
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  email: string;

  @Column()
  username: string;

  @ManyToMany(() => Room, room => room.participants)
  rooms: Room[];

  @OneToMany(() => ChatMessage, message => message.sender)
  messages: ChatMessage[];
}

@Entity()
export class Room {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  name: string;

  @Column({ default: 4 })
  maxParticipants: number;

  @ManyToMany(() => User, user => user.rooms)
  @JoinTable()
  participants: User[];

  @OneToMany(() => ChatMessage, message => message.room)
  messages: ChatMessage[];
}
```


### **Phase 2: Real-time Communication (Week 2)**

**Day 1-3: Socket.io Integration**

```typescript
@WebSocketGateway({
  cors: { origin: 'http://localhost:3000' },
  namespace: '/video'
})
export class VideoGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer() server: Server;
  
  private activeRooms = new Map<string, Set<string>>();

  @SubscribeMessage('join_room')
  async handleJoinRoom(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { roomId: string, userId: string }
  ) {
    await client.join(data.roomId);
    
    // Notify other participants
    client.to(data.roomId).emit('user_joined', {
      userId: data.userId,
      socketId: client.id
    });
    
    // Send current participants list
    const participants = this.getRoomParticipants(data.roomId);
    client.emit('room_participants', participants);
  }
```

**Day 4-7: WebRTC Client Implementation**

```typescript
// WebRTC peer connection setup
const peerConfiguration = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    // Add COTURN server for production
  ],
};

class WebRTCManager {
  private peerConnections = new Map<string, RTCPeerConnection>();
  private localStream: MediaStream | null = null;

  async initializeLocalStream() {
    this.localStream = await navigator.mediaDevices.getUserMedia({
      video: { width: 640, height: 480 },
      audio: true
    });
    return this.localStream;
  }

  async createPeerConnection(remoteUserId: string) {
    const peerConnection = new RTCPeerConnection(peerConfiguration);
    
    // Add local tracks
    this.localStream?.getTracks().forEach(track => {
      peerConnection.addTrack(track, this.localStream!);
    });

    this.peerConnections.set(remoteUserId, peerConnection);
    return peerConnection;
  }
}
```


### **Phase 3: Database \& Chat Features (Week 3)**

**Day 1-3: Chat Message System**

```typescript
// MongoDB for chat messages (flexible schema)
@Entity('chat_messages', { database: 'minimeet_chat' })
export class ChatMessage {
  @ObjectIdColumn()
  _id: ObjectId;

  @Column()
  roomId: string;

  @Column()
  senderId: string;

  @Column()
  message: string;

  @Column()
  timestamp: Date;

  @Column('simple-json')
  metadata: {
    messageType: 'text' | 'system' | 'file';
    reactions?: string[];
    editedAt?: Date;
  };
}
```

**Day 4-5: Redis Integration**

```typescript
// Redis for session management and caching
@Injectable()
export class RedisService {
  private redisClient: Redis;

  constructor() {
    this.redisClient = new Redis({
      host: 'localhost',
      port: 6379,
    });
  }

  // Cache active room participants
  async cacheRoomParticipants(roomId: string, participants: string[]) {
    await this.redisClient.setex(
      `room:${roomId}:participants`, 
      300, // 5 minutes TTL
      JSON.stringify(participants)
    );
  }

  // User presence management
  async setUserOnline(userId: string) {
    await this.redisClient.setex(`user:${userId}:status`, 600, 'online');
  }
}
```

**Day 6-7: Search with ElasticSearch**

```typescript
// ElasticSearch for chat history search
@Injectable()
export class SearchService {
  private esClient: Client;

  async indexChatMessage(message: ChatMessage) {
    await this.esClient.index({
      index: 'chat-messages',
      body: {
        roomId: message.roomId,
        senderId: message.senderId,
        message: message.message,
        timestamp: message.timestamp,
      }
    });
  }

  async searchChatHistory(roomId: string, query: string) {
    const response = await this.esClient.search({
      index: 'chat-messages',
      body: {
        query: {
          bool: {
            must: [
              { match: { roomId } },
              { match: { message: query } }
            ]
          }
        }
      }
    });
    return response.body.hits.hits;
  }
}
```


### **Phase 4: Analytics \& Media Server (Week 4)**

**Day 1-3: Event Streaming (Redis Streams instead of Kafka)**

```typescript
@Injectable()
export class EventStreamService {
  async publishCallEvent(event: {
    type: 'call_started' | 'call_ended' | 'user_joined' | 'user_left';
    roomId: string;
    userId: string;
    timestamp: Date;
    metadata?: any;
  }) {
    await this.redisClient.xadd(
      'call-events',
      '*',
      'event', JSON.stringify(event)
    );
  }

  // Process events for analytics
  async processCallEvents() {
    const events = await this.redisClient.xread('STREAMS', 'call-events', '$');
    // Process and store in analytics database
  }
}
```

**Day 4-5: Simple SFU for Group Calls**

```typescript
// Simplified media forwarding (instead of full Janus)
@Injectable()
export class MediaForwardingService {
  private roomConnections = new Map<string, Set<string>>();

  @SubscribeMessage('forward_media_offer')
  handleMediaOffer(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { roomId: string, offer: RTCSessionDescription, targetUserId: string }
  ) {
    // Forward offer to specific user in room
    client.to(data.roomId).emit('receive_media_offer', {
      offer: data.offer,
      fromUserId: client.id,
      targetUserId: data.targetUserId
    });
  }
}
```

**Day 6-7: gRPC Internal Communication**

```typescript
// gRPC service for internal microservice communication
@GrpcMethod('UserService', 'GetUserProfile')
async getUserProfile(data: { userId: string }): Promise<UserProfile> {
  const user = await this.usersService.findById(data.userId);
  return {
    id: user.id,
    username: user.username,
    status: await this.redisService.getUserStatus(user.id),
  };
}
```


## **Deployment Strategy**

### **Docker Compose Setup**

```yaml
version: '3.8'
services:
  app:
    build: ./minimeet-server
    ports:
      - "3001:3000"
    depends_on:
      - mysql
      - mongodb
      - redis
      - elasticsearch

  mysql:
    image: mysql:8.0
    environment:
      MYSQL_DATABASE: minimeet
      MYSQL_ROOT_PASSWORD: password

  mongodb:
    image: mongo:6.0
    ports:
      - "27017:27017"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  elasticsearch:
    image: elasticsearch:8.8.0
    environment:
      - discovery.type=single-node
    ports:
      - "9200:9200"
```


## **Portfolio Demonstration Features**

**What This POC Demonstrates**:
✅ **NestJS + TypeScript** → Professional backend architecture
✅ **TypeORM** → Multi-database management (MySQL + MongoDB)
✅ **Socket.io + WebRTC** → Real-time video communication
✅ **Redis** → Caching and session management
✅ **ElasticSearch** → Search functionality
✅ **Event Streaming** → Analytics pipeline
✅ **gRPC** → Internal service communication
✅ **Docker** → Containerization (simulating EKS deployment)

**Impressive Technical Details**:

- Handles both 1-on-1 and group video calls
- Real-time chat with search functionality
- User presence and analytics
- Clean separation of concerns
- Production-ready patterns in development environment

This POC directly maps to their production architecture while being completely buildable for your portfolio. Each component demonstrates your understanding of their specific technology choices and video chat domain expertise.

